# MSA #
## 모놀리식 아키텍처 ##
 하나의 시스템이 서비스 전체 기능을 처리하도록 설계한 아키텍처
#### 장점 ####
<b>1. 네트워크로 인한 지연이나 데이터 유실이 없음</b>
- MSA는 서비스 단위로 기능이 개발되므로 데이터가 MSA 사이에서 전송되며, 네트워크를 통해 전송되면서 지연이나 유실의 위험이 있음
- 모놀리식 아키테거는 클래스의 조합으로 이루어지며, 데이터는 객체들 사이에서만 전달됨

<b>2. 시스템 장애나 버그 발생 시 하나의 애플리케이션에서 원인 파악이 가능함</b>

<br />

#### 단점 ####
<b>1. 소스 코드와 복잡도가 증가함</b>

<b>2. 시스템 확장이 어려움</b>
- 주문과 결제 기능이 있는 애플리케이션에서 주문 기능의 요청이 훨씬 많은 경우, 서버를 Scale-out 해서 처리 능력을 선형적으로 늘리는 것은 비효율적임

<br />
<br />
<br />

## 마이크로 서비스 아키텍처 ##
<b style="color:skyblue">기능 위주로 나눠진 여러 애플리케이션이 있고, 각각 독립된 데이터 저장소를 사용함</b>
- 기능으로 분리된 애플리케이션들은 미리 정의된 API를 통해 서로 유기적으로 동작함
- 각 애플리케이션은 다양한 언어와 데이터베이스로 구성될 수 있음

<br />

<b style="color:skyblue">마이크로 서비스들은 다른 마이크로 서비스에 독립적으로 구성되어야 함</b>
- 서비스에 장애가 발생했을 때 다른 서비스에 영향을 끼치는 <span style="color:orange">단일 장애 지점</span>이 존재하면 안됨
- 따라서 마이크로 서비스마다 각각 독립된 데이터 저장소가 필요함
  - 데이터 저장소를 공유할 경우, 특정 마이크로 서비스가 데이터 저장소의 리소스를 모두 차지해서 다른 서비스가 데이터를 처리하지 못해 데이터 저장소가 단일 장애 지점이 될 수 있기 때문

<br />

<b style="color:skyblue">마이크로 서비스는 기능과 성격에 맞게 잘 분리되어야 함</b>
- 특정 마이크로 서비스에 기능을 집중하면 서비스 전체가 하나의 마이크로 서비스에 의존하게 됨
- 너무 세밀하게 분리하면 수많은 마이크로 서비스를 관리해야 함

<br />

<b style="color:skyblue">통신에 사용되는 네트워크 프로토콜은 가벼워야 함</b>
- 각 마이크로 서비스 컴포넌트는 API를 통해 통신하는데 API가 사용하는 네트워크 프로토콜이 성능 저하의 원인이 될 수 있음
  - 네트워크를 통해 전달되는 데이터 객체는 바이트 형태로 직렬화 되어야 하고, 받는 쪽에서는 바이트 데이터를 객체로 역직렬화 함
  - 직렬화 된 바이트의 크기가 너무 크면 네트워크 성능 저하가 발생하고, 직렬화/역직렬화 과정에서 CPU 같은 시스템 리소스를 많이 사용하면 전반적인 성능 저하가 발생함
- 보통 JSON 형식의 메시지를 주고 받으며, HTTP 기반의 REST API를 사용함
- 비동기 처리를 위해 AMQP 프로토콜을 사용하는 메시지 큐 시스템 기반으로 데이터를 주고받을 수 있음 (RabbitMQ, Kafka ...)
  - 메시지 큐 시스템 기반의 데이터 교환은 REST API보다 높은 신뢰성을 제공하지만, 메시지 큐에 의존하게 되어 단일 장애 지점이 될 수 있음

#### 장점 ####
<b>1. 독립성</b>
<br />
하나의 마이크로 서비스는 하나의 기능을 담당하므로 다른 마이크로 서비스와의 간섭이 최소화됨

<b>2. 대용량 데이터 처리가 비교적 자유로움</b>
<br />
마이크로 서비스는 독립된 데이터 저장소를 갖기 때문에 대용량 데이터를 마이크로 서비스마다 나누어 저장할 수 있음

<b>3. 장애에 견고함</b>
<br />

<b>4. 빠른 배포 주기</b>
<br />
모놀리식 아키텍처와 달리, 마이크로 서비스는 모든 기능이 분리되어 있으므로 필요한 기능만 먼저 배포할 수 있음

<b>5. 높은 확장성</b>
<br />
필요한 마이크로 서비스만 확장하면 되므로 효율적으로 시스템 자원을 활용할 수 있고 <span style="color:gray">(위에서의 주문과 결제 예시)</span>, 클라우드 시스템과 결합하면 동적 확장도 가능함

<br />

#### 단점 ####
<b>1. 어려운 개발</b>
<br />
마이크로 서비스가 네트워크 상에서 분산되어 있기 때문에 데이터나 네트워크를 등 여러 상황을 고려해야 함

마이크로 서비스는 독립적인 데이터 저장소를 갖기 때문에 데이터가 분산되어 있고, RDB의 트랜잭션을 사용할 수 없어 <span style="color:orange">데이터 정합성</span>이 맞지 않는 경우도 발생함

또한 네트워크를 통해 데이터를 통합해야 하는데, 네트워크는 신뢰할 수 없고 커넥션 비용도 비쌈

<b>2. 어려운 운영</b>
<br />
하나의 사용자 요청을 처리하기 위해 여러 마이크로 서비스가 통합되어 이용되는데, 요청 수행 중 에러가 발생했다면 어디서 에러가 발생했는지 찾기 쉽지 않음

<b>3. 어려운 설계</b>
<br />
각 마이크로 서비스가 관리하는 데이터들이 중복될 수 있고, 과도한 네트워크 통신이 발생하여 전체적인 시스템 성능이 저하될 수 있음

<br />
<br />
<br />

### MSA 설계 ###
올바른 마이크로 서비스는 서로 겹치지 않고 독립적으로 서비스 되어야 함

그렇다면 잘 설계하기 위해서는?

#### 1. 서비스 세분화 원칙 ####
서비스 지향 아키텍처의 핵심 원칙 중 하나로 4가지 요소를 기반으로 서비스를 나누는 원칙

- <b style="color:skyblue">①  비즈니스 기능</b>

<br />

- <b style="color:skyblue">② 성능</b>

  마이크로 서비스의 성능이 떨어진다면 성능 저하의 원인이 비효율적인 개발 때문인지, 서비스 크기가 너무 크기 때문인지 판단해야 함

<br />

- <b style="color:skyblue">③ 메시지 크기</b>

  메시지 크기가 너무 크다면 직렬화/역직렬화 시 성능 문제가 발생할 수 있음

<br />

- <b style="color:skyblue">④ 트랜잭션</b>

  데이터 정합성을 유지하는 트랜잭션으로 서비스를 나누는 것도 좋음

<br />

#### 2. DDD의 bounded context ####
도메인은 비즈니스 전체 혹은 조직이 하는 일을 의미하고, 도메인은 서브 도메인들로 구분할 수 있음

개발자가 도메인 구현 시 도메인 모델을 모델링 하는데 이 때, 도메인 모델이 존재하는 다른 도메인 모델과 확연히 구분되는 명시적인 경계를 <span style="color:orange">bounded context</span>라 함

bounded context는 다른 도메인 모델과 구분되므로 독립적인 영역이며, 다른 마이크로 서비스와 중복될 확률이 줄어듦

<br />

#### 3. 단일 책임 원칙 ####

<br />

#### 4. 가벼운 통신 프로토콜 ####
마이크로 서비스는 데이터 통합 시 네트워크를 사용하는데 이 때, 응답 지연, 직렬화/역직렬화 등의 문제가 시스템에 부하를 줌

부하를 최소한으로 줄이기 위해서 마이크로 서비스 간 네트워크 통신은 가벼워야 하고, 프로토콜은 특정 기술이나 언어에 의존하지 않아야 함

<br />

#### 5. 독립된 데이터 저장소 ####
하나의 데이터 저장소를 사용하게 될 경우 특정 마이크로 서비스가 과도하게 DB 자원을 사용하게 된다면 부하가 높아질 것이고, 같은 DB를 사용하는 다른 마이크로 서비스도 영향을 받게 됨

현실적으로 데이터 저장소를 분리할 수 없는 상황이라면 적어도 논리적으로 데이터 저장소를 분리하는 것이 좋음

어떤 마이크로 서비스는 데이터 정합성이 중요하고, 다른 마이크로 서비스는 처리 속도와 처리량이 중요할 수 있음

따라서 데이터 정합성이 중요한 서비스는 적합한 RDBMS를 사용하고, 데이터 조회 및 노출 서비스는 인메모리 데이터 그리드를 고려할 수 있음