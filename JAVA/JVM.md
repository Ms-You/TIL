# JVM #
JVM은 Java Virtual Machine의 약자로 JRE에 포함되어 자바 애플리케이션을 실행하기 위한 프로그램임

## JVM의 특징 ##
자바 애플리케이션은 JVM 위에서 동작하기 때문에 운영체제에 종속되어 있지 않아 서로 다른 OS에서 동일한 환경으로 애플리케이션을 실행할 수 있음
<br />

이처럼 자바는 WORA(Write Once, Read Anywhere)라는 특성을 갖고 있으며, 이식성이 높다는 장점이 있음
단, JVM은 OS에 종속적이므로 각 OS에 맞는 JVM을 설치해야 함

그렇기 때문에 사용자는 애플리케이션을 실행하기 위해 각 OS에 맞는 JVM을 설치해야 하지만, 개발자 입장에서는 OS를 신경쓰지 않고 동일한 방식으로 개발할 수 있다는 장점이 있음

단점으로는 자바 애플리케이션을 실행하기 위해서는 JVM을 거쳐야 하므로, 상대적으로 실행 속도가 느림
- 이를 보완하기 위해서 JVM에는 JIT(Just In Time) 컴파일러가 존재한느데 필요한 부분만을 기계어로 변환하므로 성능 향상을 기대할 수 있음

  (그래도 C언어 보다는 속도가 느림)

<br />
<br />
<br />

## 자바 애플리케이션의 실행 ##
1. 자바 컴파일러가 소스 코드 (.java)를 바이트 코드(.class)로 변환함
2. JVM 내에 있는 <b style="color: orange">클래스 로더</b>가 바이트 코드를 JVM의 런타임 데이터 영역에 로드함
3. 로드된 바이트 코드는 JVM에서 <b style="color: orange">실행 엔진</b>을 통해 기계어로 변환됨
4. 이 과정에서 실행 엔진에 의해 가비지 컬렉터의 동작이나 스레드의 동기화가 이루어짐

<br />
<br />
<br />

## 클래스 로더 (Class Loader) ##
JVM 내로 클래스 파일을 동적으로 로드 및 링크를 통해 배치하는 작업을 수행하는 모듈

즉, 로드된 바이트 코드를 JVM 내의 런타임 데이터 영역에 배치함

클래스를 메모리에 올리는 로딩은 한 번에 올리는 것이 아닌, 애플리케이션에서 필요한 경우에 동적으로 메모리에 적재함

클래스의 로딩은 로드(Loading) → 링크(Linking) → 초기화(Initialization)으로 구성됨

<br />
<br />

1. <b style="color: orange">로드(Loading)</b>
    - 클래스 파일을 JVM의 메모리에 로드함
2. <b style="color: orange">링크(Linking)</b>
    - 클래스 파일을 사용하기 위해 검증함
3. <b style="color: orange">초기화(Initialization)</b>
    - 클래스 변수들을 적절한 값으로 초기화 함

<br />
<br />

## 실행 엔진 (Execution Engine) ##
실행 엔진은 클래스 로더를 통해 바이트 코드가 런타임 데이터 영역에 배치되었다면 이를 명령어 단위로 읽어서 실행함

즉, 바이트 코드를 JVM 내부에서 기계어로 변환함

이 과정에서 <b style="color: orange">인터프리터</b>와 <b style="color: orange">JIT 컴파일러</b>를 같이 사용해서 바이트 코드를 실행함

<br />
<br />

#### 인터프리터 ####
- 바이트 코드를 명령어 단위로 읽어서 해석하고 바로 실행함
- 바이트 코드는 기본적으로 인터프리터 방식으로 동작함
- 메서드를 호출할 때마다 매번 해석하고 실행해야 하므로 속도가 느림

<br />

#### JIT 컴파일러 ####
- 인터프리터의 느린 속도를 보완하기 위해 JIT 컴파일러가 같이 사용됨
- 바복되는 코드는 바이트 코드 전체를 컴파일 하여 Native Code로 변경하고, 더 이상 인터프리팅 하지 않고 캐싱해 두었다가 Native Code로 직접 실행함
- 바이트 코드를 Native Code로 변환할 때 비용이 소요되므로 보통 인터프리터와 같이 사용함

<br />
<br />
<br />

## 런타임 데이터 영역 (Runtime Data Area) ##
JVM의 메모리 영역으로 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역

Method Area, Heap Area는 모든 스레드가 접근 가능하며 공유하는 영역이고,
Stack Area, PC Register, Native Method Stack Area는 각 스레드 마다 개별로 생성되는 영역임

<br />

### 메서드 영역 (Method Area) ###
모든 스레드가 공유하는 영역으로, JVM이 시작될 때 생성되는 공간

바이트 코드를 처음 메모리에 올릴 때 초기화되는 대상을 저장하기 위함

메서드 영역은 JVM이 동작하고 클래스가 로드될 때 적재돼서 프로그램이 종료될 때까지 저장됨

<br />
<br />

아래와 같은 정보를 저장함
- Field Info - 멤버 변수의 이름, 데이터 타입, 접근 제어자 정보
- Method Info - 메서드 이름, 반환 타입, 함수 매개 변수
- Type Info - 클래스인지 인터페이스인지 여부, 타입의 속성

<br />
<br />

### 힙 영역 (Heap Area) ###
메서드 영역과 함께 모든 스레드가 공유하며, 데이터를 저장하기 위해 런타임 시 동적으로 할당해서 사용되는 메모리 영역

new 키워드로 생성된 객체나 배열이 저장되는 영역으로 메서드 영역에 저장된 클래스만이 생성되어 적재됨

힙 영역에 생성된 객체와 배열은 JVM의 스택 영역에서 참조해서 사용함

- 참고로 가비지 컬렉터의 대상 영역으로 참조되는 변수나 필드가 없다면 가비지 컬렉터가 동작해서 참조되지 않는 객체를 힙 영역에서 제거함

<br />
<br />

### 스택 영역 (Stack Area) ###
임시적으로 사용되는 변수나 정보들이 저장되는 영역임

즉, 메서드 안에서 사용되는 값들을 저장하고 지역 변수나 매개 변수, 반환 값 등을 임시로 저장하며 메서드 수행이 종료되면 스택 프레임 별로 삭제됨

  - 스택 프레임 - 메서드가 호출될 때마다 프레임이 만들어지며, 실행중인 메서드의 상태 정보를 저장하는 곳임

스택 영역은 스레드마다 고유하며, 스레드가 시작될 때 할당 됨

프로세스가 메모리에 로드될 때 스택 사이즈가 고정되어 있으므로 런타임 시에 스택 사이즈를 변경할 수는 없음


