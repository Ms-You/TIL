## Index ##
DB에서 원하는 데이터를 빠르게 찾을 수 있도록 도와주는 자료구조

테이블의 모든 데이터를 검색하면 시간이 오래 걸리기 때문에 데이터와 데이터의 위치를 포함한 인덱스를 바탕으로 원하는 데이터를 빠르게 찾을 수 있음

<br />
<br />

#### 인덱스의 장점 ####
- <b>검색 속도 향상</b> (대용량 테이블에서 효과적)
- <b>정렬 속도 향상</b> (ORDER BY 절을 통해 정렬할 때 보다 빠른 정렬이 가능)

<br />

#### 인덱스의 단점 ####
- <b>추가 저장 공간 필요</b> (테이블 크기의 약 10% 공간이 추가로 필요함)
- <b>쓰기 성능 저하</b> (데이터를 변경하면 인덱스도 업데이트 해야 함)
- <b>너무 많은 인덱스</b> (DB가 쿼리를 실행할 때 어떤 인덱스를 사용할지 결정해야 하는데 인덱스가 너무 많으면 선택에 시간이 더 걸릴 수 있음)

<br />
<br />

### 인덱스의 종류 ###
<b>1. 클러스터형 인덱스</b>
- 테이블의 데이터를 인덱스 키 값에 따라 물리적으로 정렬함
  - 즉, 데이터가 저장될 때 인덱스 키 값의 순서대로 저장됨
- 테이블 당 하나의 인덱스만 생성 가능
- 기본 키에 인덱스를 자동으로 생성함
- 클러스터형 인덱스를 사용하는 쿼리는 데이터에 직접 접근하므로 범위 검색이나 정렬된 데이터를 필요로 하는 쿼리에서 효율적임

장점
- 빠른 검색 속도
- 관련 데이터가 함께 저장되어 있으므로 캐싱 효율성을 높일 수 있음

단점
- 삽입, 수정, 삭제 시 데이터의 물리적 위치를 변경해야 하므로 쓰기 작업 성능 저하
- 테이블 당 하나의 인덱스만 생성 가능하므로 신중해야 함
- 데이터 자체를 포함하므로 인덱스 크기가 클 수 있음

<b>2. 비클러스터형 인덱스</b>
- 데이터의 물리적인 정렬 순서와 독립적으로 인덱스 키 값을 정렬함
- 테이블 당 여러 개의 인덱스를 생성 가능
- 인덱스에서 키 값을 찾은 다음 해당 키 값에 연결된 포인터를 통해 실제 데이터 행에 접근함

장점
- 테이블 당 여러 개의 인덱스 생성이 가능하므로 다양한 검색 조건에 대한 쿼리 성능 향상 가능
- 삽입, 수정, 삭제 시 데이터의 물리적인 위치를 변경하지 않아도 되므로 쓰기 작업 성능 유지
- 클러스터형 인덱스에 비해 크기가 작을 수 있음

단점
- 인덱스만 정렬되고 실제 데이터는 정렬되지 않으므로 클러스터형 인덱스에 비해 검색 속도가 느림

<b>3. B-트리 인덱스</b>
- 가장 일반적인 인덱스
- 균형 잡힌 트리 구조로 데이터의 정렬 순서를 유지함
- 등호 (=), 부등호 (<, >, <=, >=), BETWEEN, LIKE 등의 연산에 효율적

<b>4. 해시 인덱스 </b>
- 해시 함수를 사용해서 인덱스 키를 계산하고, 해당 키에 대한 데이터 위치를 저장함
- 등호 (=) 연산이 매우 빠르지만, 범위 검색 (<, >, BETWEEN)에 적합하지 않음

<br />
<br />

### B-트리 인덱스 ###
루트 노드
- 최상위 노드로 인덱스 검색의 시작점이 됨
중간 노드
- 루트 노드와 리프 노드 사이에 위치하며 자식 노드를 가리키는 포인터를 가지고 있음
리프 노드
- 최하위 노드로 실제 데이터나 데이터의 위치 정보를 저장함

<br />

<b>데이터 검색 효율성</b>
- B-트리는 균형 트리 구조이므로 루트 노드에서 리프 노드까지의 거리가 모든 경로에서 거의 같음
- 따라서 검색에 필요한 페이지 탐색 횟수가 예측 가능하며, 데이터 양이 증가되어도 검색 성능이 크게 차이나지 않음
- 페이지 탐색 횟수는 인덱스의 깊이(depth)에 따라 결정됨
- 페이지 크기는 일반적으로 16kB임
- 페이지 단위로 데이터를 읽고 쓰므로 페이지 탐색 횟수를 줄이는 것이 성능 향상에 중요함

<br />
<br />
<br />

### 인덱스 생성 ###
```SQL
CREATE [UNIQUE] INDEX index_name ON table_name (column1, column2, ...);
```
- UNIQUE는 중복이 아닌 고유 인덱스를 생성하기 위한 것으로 생략 시 중복을 허용함

### 인덱스 수정 ###
```SQL
ALTER TABLE table_name ADD INDEX index_name (column1, column2, ...);
```
- MySQL에서는 인덱스 이름을 직접 변경하는 것이 불가능하므로 기존 인덱스를 삭제하고 새로운 이름으로 인덱스를 다시 생성해야 함

```SQL
ALTER TABLE table_name DROP INDEX index_name;
ALTER TABLE table_name ADD INDEX index_name (column1, ...);
```

### 인덱스 제거 ###
```SQL
DROP INDEX index_name ON table_name;
```
- 기본 키로 자동 생성된 인덱스는 DROP 문으로 삭제할 수 없음

<br />
<br />
<br />

### 인덱스를 사용하지 않고 조회하는 경우 ###
- 인덱스 조건이 누락 되었을 경우 (FULL SCAN 때림)
```SQL
SELECT * FROM MEMBER;
```
- 전체 테이블 검색이 더 빠를 때 (굳이 인덱스 사용할 이유가 없음)

=> 따라서 WHERE 절에 자주 사용되는 컬럼에 인덱스를 만드는 것이 좋음

